
#### https://medium.com/@jkaluzka/taking-a-snapshot-of-the-browser-in-case-of-error-using-selenium-and-pytest-e5c1b5073843
from pathlib import Path

@pytest.hookimpl(hookwrapper=True)
def pytest_exception_interact(node, call, report):
    """
    Overrides the original hook to save browser state
    in form of a screenshot into the "./errors" directory
    """
    web_driver = None
    for fixture_name in node.fixturenames:
        web_driver = node.funcargs[fixture_name]
        if isinstance(web_driver, webdriver.Chrome) or isinstance(web_driver, webdriver.Firefox):
            break
    if not web_driver:
       yield

    _path = "./errors"
    Path(_path).mkdir(parents=True, exist_ok=True)
    name = "-".join(node.nodeid.split("::")[-2:])
    web_driver.save_screenshot(f"{_path}/error_{name}.png")


   """In the above code, we are fiding a fixture, that would have a driver variable that can be used
   to take a snapshot of the browser. If it is not found, then we don’t do anything. Let’s be honest,
   this code makes sense only for tests that use Selenium Driver,
   all errors raised for non Selenium setup will be already printed to the stdout.

The hook will be used automatically, so by running the prepared failing tests once again,
new folder errors will be created with a Browser state snapshot.